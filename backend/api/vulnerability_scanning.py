from flask import request, jsonify, g
from flask_jwt_extended import jwt_required, get_jwt_identity
from db import db, User, VulnerabilityReport
import json
import time
from datetime import datetime

def register_vulnerability_routes(app, limiter):
    """
    Register routes for JWT vulnerability scanning.
    
    Routes include:
    - Scan token for vulnerabilities
    - Get vulnerability report
    - Assess token security posture
    """
    
    @app.route('/api/scan/token', methods=['POST'])
    @limiter.limit("15/minute")
    def scan_token_vulnerabilities():
        """Scan a JWT token for potential vulnerabilities"""
        if not request.is_json:
            return jsonify({"error": "Missing JSON in request"}), 400
            
        data = request.json or {}
        token = data.get('token', '')
        
        if not token:
            return jsonify({"error": "Token is required"}), 400
            
        # Use JWT utils to decode the token
        jwt_utils = g.jwt_utils
        decoded = jwt_utils.decode_token_parts(token)
        
        if "error" in decoded:
            return jsonify({"error": decoded["error"]}), 400
            
        # Analyze the token for vulnerabilities
        scanner = g.vulnerability_scanner
        scan_results = scanner.scan_token(token, decoded)
        
        # Log the activity
        username = get_jwt_identity() if hasattr(g, 'jwt') else "anonymous"
        g.audit_manager.log_event(
            event_type="token_scanned",
            username=username,
            details=f"Vulnerability scan performed: {len(scan_results['vulnerabilities'])} issues found"
        )
        
        return jsonify(scan_results)
    
    @app.route('/api/scan/save-report', methods=['POST'])
    @jwt_required()
    def save_scan_report():
        """Save a vulnerability scan report"""
        if not request.is_json:
            return jsonify({"error": "Missing JSON in request"}), 400
            
        data = request.json or {}
        token = data.get('token', '')
        scan_results = data.get('results', {})
        token_name = data.get('name', f"Token {datetime.utcnow().isoformat()}")
        
        if not token or not scan_results:
            return jsonify({"error": "Token and scan results are required"}), 400
            
        current_user = get_jwt_identity()
        user = User.query.filter_by(username=current_user).first()
        
        if not user:
            return jsonify({"error": "User not found"}), 404
            
        # Calculate risk score based on vulnerability severity
        risk_score = 0
        vulnerabilities = scan_results.get('vulnerabilities', [])
        for vuln in vulnerabilities:
            severity = vuln.get('severity', 'low').lower()
            if severity == 'critical':
                risk_score += 10
            elif severity == 'high':
                risk_score += 7
            elif severity == 'medium':
                risk_score += 4
            elif severity == 'low':
                risk_score += 1
        
        # Create new vulnerability report
        report = VulnerabilityReport()
        report.token_name = token_name
        report.token = token
        report.user_id = user.id
        report.results = json.dumps(scan_results)
        report.risk_score = risk_score
        report.created_at = datetime.utcnow()
        
        db.session.add(report)
        db.session.commit()
        
        # Log the activity
        g.audit_manager.log_event(
            event_type="vulnerability_report_saved",
            username=current_user,
            details=f"Vulnerability report saved: {token_name} (Risk Score: {risk_score})"
        )
        
        return jsonify({
            "message": "Vulnerability report saved successfully",
            "report_id": report.id,
            "risk_score": risk_score
        })
    
    @app.route('/api/scan/assess', methods=['POST'])
    @limiter.limit("15/minute")
    def assess_token_security():
        """Perform a comprehensive security assessment of a JWT token"""
        if not request.is_json:
            return jsonify({"error": "Missing JSON in request"}), 400
            
        data = request.json or {}
        token = data.get('token', '')
        include_fixes = data.get('include_fixes', True)
        
        if not token:
            return jsonify({"error": "Token is required"}), 400
            
        # Use JWT utils to decode the token
        jwt_utils = g.jwt_utils
        decoded = jwt_utils.decode_token_parts(token)
        
        if "error" in decoded:
            return jsonify({"error": decoded["error"]}), 400
            
        # Analyze the token for vulnerabilities
        scanner = g.vulnerability_scanner
        scan_results = scanner.scan_token(token, decoded)
        
        # Add security assessment
        header = decoded.get('header', {})
        payload = decoded.get('payload', {})
        
        # Check header security
        header_assessment = {
            "algorithm": {
                "value": header.get('alg'),
                "secure": header.get('alg') not in ['none', 'HS256'],
                "recommendation": "Consider using RS256, ES256, or EdDSA instead of HS256 or none" if header.get('alg') in ['none', 'HS256'] else None
            },
            "type": {
                "value": header.get('typ'),
                "secure": header.get('typ') == 'JWT',
                "recommendation": "Set type to JWT" if header.get('typ') != 'JWT' else None
            }
        }
        
        # Check payload security
        expiry = payload.get('exp')
        now = int(time.time())
        
        payload_assessment = {
            "expiration": {
                "value": expiry,
                "secure": expiry is not None and expiry > now,
                "recommendation": "Add an expiration claim (exp)" if expiry is None else None
            },
            "issuer": {
                "value": payload.get('iss'),
                "secure": payload.get('iss') is not None,
                "recommendation": "Add an issuer claim (iss)" if payload.get('iss') is None else None
            },
            "audience": {
                "value": payload.get('aud'),
                "secure": payload.get('aud') is not None,
                "recommendation": "Add an audience claim (aud)" if payload.get('aud') is None else None
            },
            "issued_at": {
                "value": payload.get('iat'),
                "secure": payload.get('iat') is not None,
                "recommendation": "Add an issued-at claim (iat)" if payload.get('iat') is None else None
            }
        }
        
        # Calculate overall security score
        total_checks = 0
        passed_checks = 0
        
        for assessment in [header_assessment, payload_assessment]:
            for check in assessment.values():
                total_checks += 1
                if check.get('secure'):
                    passed_checks += 1
        
        # Count vulnerabilities by severity
        vuln_counts = {
            "critical": 0,
            "high": 0,
            "medium": 0,
            "low": 0,
            "info": 0
        }
        
        for vuln in scan_results.get('vulnerabilities', []):
            severity = vuln.get('severity', 'info').lower()
            if severity in vuln_counts:
                vuln_counts[severity] += 1
        
        # Generate suggested fixes if requested
        suggested_fixes = None
        if include_fixes:
            suggested_fixes = {}
            
            # Header fixes
            if header.get('alg') in ['none', 'HS256']:
                key_manager = g.key_manager
                rsa_key_pair = key_manager.generate_rsa_key_pair()
                suggested_fixes['header'] = {
                    'alg': 'RS256'
                }
                suggested_fixes['signing_key'] = rsa_key_pair['private_key']
                suggested_fixes['verification_key'] = rsa_key_pair['public_key']
            
            # Payload fixes
            payload_fixes = {}
            if expiry is None:
                payload_fixes['exp'] = now + 3600  # 1 hour from now
            if payload.get('iat') is None:
                payload_fixes['iat'] = now
            if payload.get('iss') is None:
                payload_fixes['iss'] = "https://jwtsecurity.example.com"
            if payload.get('aud') is None:
                payload_fixes['aud'] = "example-api"
            if payload.get('jti') is None:
                payload_fixes['jti'] = jwt_utils.generate_jti()
                
            if payload_fixes:
                suggested_fixes['payload'] = payload_fixes
                
            # Generate example fixed token
            if suggested_fixes.get('header') or suggested_fixes.get('payload'):
                fixed_header = {**header}
                fixed_payload = {**payload}
                
                if suggested_fixes.get('header'):
                    fixed_header.update(suggested_fixes['header'])
                
                if suggested_fixes.get('payload'):
                    fixed_payload.update(suggested_fixes['payload'])
                
                signing_key = suggested_fixes.get('signing_key', '')
                algorithm = fixed_header.get('alg', 'RS256')
                
                # Create a fixed token example
                suggested_fixes['fixed_token'] = jwt_utils.create_token(
                    fixed_payload, 
                    signing_key, 
                    algorithm, 
                    fixed_header
                )
        
        # Prepare assessment result
        assessment_result = {
            "security_score": round((passed_checks / total_checks) * 100) if total_checks > 0 else 0,
            "token_decoded": {
                "header": header,
                "payload": payload
            },
            "header_assessment": header_assessment,
            "payload_assessment": payload_assessment,
            "vulnerability_counts": vuln_counts,
            "vulnerabilities": scan_results.get('vulnerabilities', []),
            "suggested_fixes": suggested_fixes
        }
        
        # Log the activity
        username = get_jwt_identity() if hasattr(g, 'jwt') else "anonymous"
        g.audit_manager.log_event(
            event_type="token_assessment",
            username=username,
            details=f"Security assessment performed: Score {assessment_result['security_score']}%"
        )
        
        return jsonify(assessment_result) 